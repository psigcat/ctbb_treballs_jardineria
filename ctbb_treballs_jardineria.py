# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ctbb_treballs_jardineria
								 A QGIS plugin
 Incidencies de CTBB Treballs Jardineria
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
							  -------------------
		begin				: 2024-10-28
		git sha			  : $Format:%H$
		copyright			: (C) 2024 by Gerald Kogler
		email				: geraldo@servus.at
 ***************************************************************************/

/***************************************************************************
 *																		 *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or	 *
 *   (at your option) any later version.								   *
 *																		 *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QLineEdit, QDateEdit, QComboBox, QPlainTextEdit
from qgis.PyQt.QtSql import QSqlTableModel
from qgis.core import Qgis, QgsVectorLayerCache, QgsProviderRegistry, QgsProject
from qgis.gui import QgsAttributeTableFilterModel, QgsAttributeTableModel

# Import the code for the dialog
from .ctbb_treballs_jardineria_dialog import ctbb_treballs_jardineriaDialog
from .ctbb_treballs_jardineria_dialog_manage import ctbb_treballs_jardineriaDialogManage
from .ctbb_database import ctbb_database
import os.path


ARBRES_TABLE_FIELDS = ['id', 'esp_nom', ' id_vu', 'ref_zona']
DICT_TABLES = ['dic_ambit', 'dic_tipus', 'dic_esporga_temporada', 'dic_esporga_tipus', 'dic_plaga_tipus']
SELECTABLE_LAYERS = ['Arbres', 'Elements superficials', 'Elements lineals', 'Elements puntuals']
FIELDNAMES = ['id', 'ambit', 'data_inici', 'data_fi', 'tipus', 'descripcio', 'persona_de', 'persona_a', 'document', 'preu_base', 'iva', 'quantitat', 'unitat', 'preu_unitari', 'data_factura', 'data_encarreg', 'data_execucio', 'observacions', 'esporga_tipus', 'esporga_temporada', 'plaga_superficie', 'plaga_tipus', 'plaga_aplicador', 'plaga_maquina', 'plaga_brou', 'plaga_nom_comercial', 'plaga_nom_registre', 'plaga_dosis', 'plaga_observacions']
FILTER_INCIDENCIES_VALUE = '2024'
FILTER_INCIDENCIES_KEY = 'esporga_temporada'
COMBO_SELECT_MSG = "(Seleccionar)"


class ctbb_treballs_jardineria:
	"""QGIS Plugin Implementation."""

	def __init__(self, iface):
		"""Constructor.

		:param iface: An interface instance that will be passed to this class
			which provides the hook by which you can manipulate the QGIS
			application at run time.
		:type iface: QgsInterface
		"""
		# Save reference to the QGIS interface
		self.iface = iface
		# initialize plugin directory
		self.plugin_dir = os.path.dirname(__file__)
		# initialize locale
		locale = QSettings().value('locale/userLocale')[0:2]
		locale_path = os.path.join(
			self.plugin_dir,
			'i18n',
			'ctbb_treballs_jardineria_{}.qm'.format(locale))

		if os.path.exists(locale_path):
			self.translator = QTranslator()
			self.translator.load(locale_path)
			QCoreApplication.installTranslator(self.translator)

		# Declare instance attributes
		self.actions = []
		self.menu = self.tr(u'&CTBB Treballs Jardineria')

		# Check if plugin was started the first time in current QGIS session
		# Must be set in initGui() to survive plugin reloads
		self.first_start_create = None
		self.first_start_manage = None


	# noinspection PyMethodMayBeStatic
	def tr(self, message):
		"""Get the translation for a string using Qt translation API.

		We implement this ourselves since we do not inherit QObject.

		:param message: String for translation.
		:type message: str, QString

		:returns: Translated version of message.
		:rtype: QString
		"""
		# noinspection PyTypeChecker,PyArgumentList,PyCallByClass
		return QCoreApplication.translate('ctbb_treballs_jardineria', message)


	def add_action(
		self,
		icon_path,
		text,
		callback,
		enabled_flag=True,
		add_to_menu=True,
		add_to_toolbar=True,
		status_tip=None,
		whats_this=None,
		parent=None):
		"""Add a toolbar icon to the toolbar.

		:param icon_path: Path to the icon for this action. Can be a resource
			path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
		:type icon_path: str

		:param text: Text that should be shown in menu items for this action.
		:type text: str

		:param callback: Function to be called when the action is triggered.
		:type callback: function

		:param enabled_flag: A flag indicating if the action should be enabled
			by default. Defaults to True.
		:type enabled_flag: bool

		:param add_to_menu: Flag indicating whether the action should also
			be added to the menu. Defaults to True.
		:type add_to_menu: bool

		:param add_to_toolbar: Flag indicating whether the action should also
			be added to the toolbar. Defaults to True.
		:type add_to_toolbar: bool

		:param status_tip: Optional text to show in a popup when mouse pointer
			hovers over the action.
		:type status_tip: str

		:param parent: Parent widget for the new action. Defaults None.
		:type parent: QWidget

		:param whats_this: Optional text to show in the status bar when the
			mouse pointer hovers over the action.

		:returns: The action that was created. Note that the action is also
			added to self.actions list.
		:rtype: QAction
		"""

		icon = QIcon(icon_path)
		action = QAction(icon, text, parent)
		action.triggered.connect(callback)
		action.setEnabled(enabled_flag)

		if status_tip is not None:
			action.setStatusTip(status_tip)

		if whats_this is not None:
			action.setWhatsThis(whats_this)

		if add_to_toolbar:
			# Adds plugin icon to Plugins toolbar
			self.iface.addToolBarIcon(action)

		if add_to_menu:
			self.iface.addPluginToMenu(
				self.menu,
				action)

		self.actions.append(action)

		return action


	def initGui(self):
		"""Create the menu entries and toolbar icons inside the QGIS GUI."""

		icon_path = os.path.join(self.plugin_dir, 'icon.png')
		self.add_action(
			icon_path,
			text=self.tr(u'Obrir incidencia'),
			callback=self.run,
			parent=self.iface.mainWindow())
		self.add_action(
			icon_path,
			text=self.tr(u'Gestionar incidencies'),
			callback=self.manage,
			parent=self.iface.mainWindow())

		# will be set False in run()
		self.first_start_create = True
		self.first_start_manage = True


	def unload(self):
		"""Removes the plugin menu item and icon from QGIS GUI."""
		for action in self.actions:
			self.iface.removePluginMenu(
				self.tr(u'&CTBB Treballs Jardineria'),
				action)
			self.iface.removeToolBarIcon(action)


	def connect_db(self):
		# connect to database
		
		self.ctbb_db = ctbb_database(self.plugin_dir)
		self.ctbb_db.read_config()
		self.db = self.ctbb_db.open_database()


	def load_dicts(self, type=""):
		""" Load dicts for GUI """

		for table in DICT_TABLES:
			schema = self.ctbb_db.param["schema"]
			sql = f"SELECT * FROM {schema}.{table}"
			rows = self.ctbb_db.get_rows(sql)
			self.fill_combo(table, rows, type)


	def fill_combo(self, table, rows, type):
		""" Fill combo item """
	
		combo = table[4:]
		if type == "filter":
			widget_name = "filter_" + combo
			widget = self.dlg_manage.findChild(QComboBox, widget_name)
		else:
			widget_name = combo
			widget = self.dlg_create.findChild(QComboBox, widget_name)

		widget.clear()		
		widget.addItem(COMBO_SELECT_MSG)
		for row in rows:
			widget.addItem(row[1])


	def show_selected_features(self, layer, features):
		""" Show selected trees or superficies in table view """
		
		for feature in features:
			print(feature.attributes())

		#self.tableView = QgsAttributeTableView(self)
		self.layerCache = QgsVectorLayerCache(layer, len(features))
		self.modelTrees = QgsAttributeTableModel(self.layerCache)
		self.modelTrees.loadLayer()

		self.tableFilterModel = QgsAttributeTableFilterModel(self.iface.mapCanvas(), self.modelTrees, parent=self.modelTrees)
		self.tableFilterModel.setFilterMode(QgsAttributeTableFilterModel.ShowSelected)
		self.dlg_create.tbl_main.setModel(self.tableFilterModel)

		# hide columns
		# for i in range(self.model.columnCount()):
			# fieldname = self.model.headerData(i, Qt.Horizontal)
			# if fieldname not in ARBRES_TABLE_FIELDS:
				# self.dlg_create.tbl_main.setColumnHidden(i, True)
		
		# set column width
		# fieldindex = self.model.fieldIndex('esp_nom')
		# self.dlg_create.tbl_main.setColumnWidth(fieldindex, 300)


	def check_mandatory(self):
		""" check mandatory fields """
		
		return True


	def get_widget_data(self, fieldname):

		widget = None
		data = None
		if not hasattr(self.dlg_create, fieldname):
			return None, None
		widget = getattr(self.dlg_create, fieldname)
		if type(widget) == QLineEdit:
			data = widget.text()
		elif type(widget) == QPlainTextEdit:
			data = widget.toPlainText()
		elif type(widget) is QComboBox:
			data = widget.currentText()
		elif type(widget) is QDateEdit:
			date = widget.date()
			data = date.toString("yyyy-MM-dd")
		else:
			print(f"Tipus de component no suportat pel camp '{fieldname}': {type(widget)}")
		return widget, data


	def set_widget_data(self, fieldname, value):

		widget = None
		if not hasattr(self.dlg_create, fieldname):
			return None, None
		widget = getattr(self.dlg_create, fieldname)
		if type(widget) == QLineEdit:
			if value != "NULL":
				widget.setText(str(value))
		elif type(widget) == QPlainTextEdit:
			if value != "NULL":
				widget.setPlainText(str(value))
		elif type(widget) is QComboBox:
			widget.setCurrentText(str(value))
		#elif type(widget) is QDateEdit:
		#	widget.setDate(value)
		else:
			print(f"Tipus de component no suportat pel camp '{fieldname}': {type(widget)}")


	def publish_record(self, layer, features):
		""" Publish new register incidencia """
	
		# check if all mandatory fields are filled out
		if not self.check_mandatory():
			return False

		# Create dictionary with field names and widget values
		data = {}
		#fieldnames = self.ctbb_db.get_table_fields()
		#print(fieldnames)
		for fieldname in FIELDNAMES:
			widget, widget_data = self.get_widget_data(fieldname)
			if widget is None:
				print(f"El camp de la taula no tÃ© cap component associat: {fieldname}")
				continue
			data[fieldname] = widget_data

		# add tablename and selected features to data
		#print(layer.source())
		#uri_components = QgsProviderRegistry.instance().decodeUri(layer.dataProvider().name(), layer.publicSource());
		#capa_seleccionada = uri_components['schema'] + "." + uri_components['table']
		#print(capa_seleccionada)
		#data["capa_seleccionada"] = capa_seleccionada
		data["capa_seleccionada"] = layer.id()
		
		elements_seleccionats = []
		for feature in features:
			elements_seleccionats.append(feature.id())
		data["elements_seleccionats"] = ",".join(map(str,elements_seleccionats))

		self.ctbb_db.insert_record(data)
		
		self.iface.messageBar().pushMessage("Success", "Dades insertades correctament", level=Qgis.Success, duration=5)


	def load_records(self):
		""" Load table of incidencies records """

		self.modelIncidencies = QSqlTableModel(db=self.db)
		schema = self.ctbb_db.param["schema"]
		table = self.ctbb_db.param["table"]
		self.modelIncidencies.setTable(f"{schema}.{table}")
		self.modelIncidencies.setSort(4, Qt.AscendingOrder)
		self.modelIncidencies.setFilter(f"{FILTER_INCIDENCIES_VALUE} = '{FILTER_INCIDENCIES_VALUE}'")
		self.modelIncidencies.select()
		self.dlg_manage.tbl_main.setModel(self.modelIncidencies)
		
		# # hide columns
		# for i in range(self.modelIncidencies.columnCount()):
			# fieldname = self.modelIncidencies.headerData(i, Qt.Horizontal)
			# if fieldname not in ARBRES_TABLE_FIELDS:
				# self.dlg_manage.tbl_main.setColumnHidden(i, True)
		
		# # set column width
		# fieldindex = self.modelIncidencies.fieldIndex('esp_nom')
		# self.dlg_manage.tbl_main.setColumnWidth(fieldindex, 300)


	def filter_records(self):
		""" filter inciencies records by selected combobox filters """
		
		i = 0
		filter = ""
		for dict in DICT_TABLES:
			field_name = dict[4:]
			widget_name = "filter_" + field_name
			widget = self.dlg_manage.findChild(QComboBox, widget_name)
			if widget.currentText() != COMBO_SELECT_MSG:
				if i > 0:
					filter += " AND "
				filter += f"{field_name} = '{widget.currentText()}'"
				i += 1

		print("filter", filter)
		self.modelIncidencies.setFilter(filter)
		self.modelIncidencies.select()


	def get_selected_record(self):
		""" edit incidencia """

		selected_rows = self.dlg_manage.tbl_main.selectionModel().selectedRows()
		if len(selected_rows) == 0:
			self.dlg_manage.messageBar.pushMessage("Warning", "Has de seleccionar una incidencia", level=Qgis.Warning, duration=5)
			return False

		selected_row = selected_rows[0]
		selected_row_index = selected_row.row()		
		index = self.modelIncidencies.index(selected_row_index, 0)
		#data = self.modelIncidencies.data(index, Qt.DisplayRole)
		#print(f"ID of selected row {selected_row_index}: {data}")
		
		record = index.model().record(selected_row_index)
		return record


	def delete_record(self):
		""" edit incidencia """

		selected_record = self.get_selected_record()
		if not selected_record:
			return False
			
		id = selected_record.field("id").value()
		print("delete record", id)
		self.ctbb_db.delete_record(id)
		self.dlg_manage.messageBar.pushMessage("Success", "Incidencia marcada borrada", level=Qgis.Success, duration=5)
		
		# reload records
		self.load_records()


	def load_record(self, incidencia):
		""" load record from table incidencia """
		
		print("load record", incidencia)
		id = incidencia.field("id").value()
		capa_seleccionada = incidencia.field("capa_seleccionada").value()
		elements_seleccionats = incidencia.field("elements_seleccionats").value()
		elements_seleccionats = elements_seleccionats.split(",")
		elements_seleccionats = list(map(int, elements_seleccionats))
		print(id, capa_seleccionada, elements_seleccionats)
		
		self.dlg_create.id.setText(str(id))
		
		for fieldname in FIELDNAMES:
			value = incidencia.field(fieldname).value()
			self.set_widget_data(fieldname, value)

		# load related trees and superficies
		layer = QgsProject.instance().mapLayer(capa_seleccionada)
		#features = layer.getFeatures(elements_seleccionats)
		layer.select(elements_seleccionats)
		self.iface.actionZoomToSelected().trigger()
		selected_features = layer.selectedFeatures()
		
		if len(selected_features) < 1:
			self.iface.messageBar().pushMessage("Warning", "No hi ha arbres o superficies relacionats amb aquesta incidencia", level=Qgis.Warning, duration=5)
			return
		
		self.show_selected_features(layer, selected_features)


	def edit_record(self):
		""" edit incidencia """

		selected_record = self.get_selected_record()		
		if not selected_record:
			return False
			
		if self.first_start_create == True:
			self.first_start_create = False
			self.dlg_create = ctbb_treballs_jardineriaDialog()
		
			#self.connect_db()
			self.load_dicts()

		self.load_record(selected_record)
		self.dlg_create.show()
			

	def manage(self):
		""" Manage existing incidencies: Main "Gestionar incidencies" """
		
		if self.first_start_manage == True:
			self.first_start_manage = False
			self.dlg_manage = ctbb_treballs_jardineriaDialogManage()
		
			self.dlg_manage.show()
			self.dlg_manage.editBtn.clicked.connect(self.edit_record)
			self.dlg_manage.deleteBtn.clicked.connect(self.delete_record)
			
			self.connect_db()
			self.load_dicts("filter")
			self.dlg_manage.filter_esporga_temporada.setCurrentText(FILTER_INCIDENCIES_VALUE)
			self.load_records()
			
			for name in DICT_TABLES:
				widget_name = "filter" + name[3:]
				widget = self.dlg_manage.findChild(QComboBox, widget_name)
				widget.currentIndexChanged.connect(self.filter_records)
				
		self.dlg_manage.show()


	def run(self):
		""" Create new incidencies: Main "Obrir incidencia" """
		
		# get selected features
		layer = self.iface.activeLayer()
		if not layer.name() in SELECTABLE_LAYERS:
			self.iface.messageBar().pushMessage("Warning", "Capa seleccionada no permesa, has de seleccionar al menys un abre o superficie", level=Qgis.Warning, duration=5)
			return
		
		features = layer.selectedFeatures()
		if len(features) < 1:
			self.iface.messageBar().pushMessage("Warning", "Has de seleccionar al menys un abre o superficie", level=Qgis.Warning, duration=5)
			return
		
		# Only create GUI ONCE in callback, so that it will only load when the plugin is started
		if self.first_start_create == True:
			self.first_start_create = False
			self.dlg_create = ctbb_treballs_jardineriaDialog()

			# load dicts
			self.connect_db()
			self.load_dicts()

		# show the dialog
		self.dlg_create.show()
		self.show_selected_features(layer, features)
		self.dlg_create.id.setEnabled(False)
		
		# Run the dialog event loop
		result = self.dlg_create.exec_()
		# See if OK was pressed
		if result:
			# obrir incidencia
			self.publish_record(layer, features)
